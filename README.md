---

Проект подключен к БД, находяшемся на хостинге [Neon](https://console.neon.tech). При необходимости, отключить его от базы и подключить к локальной можно через настройки.

---

> Как можно было бы обновлять проект без потери пользовательских соединений?

Если мы будем использовать Nginx в качестве прокси-сервера, можно использовать upstream серверов. Определяем несколько upstream серверов для нашего приложения, каждый из которых будет обслуживать разные версии приложения (старую и новую). По мере обновления, перенаправляем часть трафика на новую версию. Также можно использовать реверс-прокси с настройкой health checks. Nginx может проверять доступность серверов upstream и автоматически исключать неисправные серверы из балансировки нагрузки. Это позволяет избежать отправки запросов на недоступные или нестабильные серверы.

Примерная конфигурации Nginx для zero-downtime deployment выглядит следующим образом:
``` nginx
http {
    upstream myapp {
        server 127.0.0.1:8000;  # старая версия приложения
        server 127.0.0.1:8001;  # новая версия приложения
    }

    server {
        listen 80;
        server_name myapp.example.com;

        location / {
            proxy_pass http://myapp;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection "upgrade";
        }
    }
}

```

В данном примере Nginx настроен на использование upstream блока myapp, который включает в себя два сервера на разных портах. По мере обновления, можно постепенно перенаправлять трафик с одного сервера на другой, используя health checks или другие механизмы.

---

> Так же было бы не лишним проверить по производительности оба поиска запчастей через утилиту wrk или siege

Пример команды для тестирования с использованием wrk
``` nginx
wrk -t4 -c100 -d30s http://127.0.0.1:8000/search/part/
```
- *c100* - количество одновременных пользователей (concurrent users), которые будут отправлять запросы.
- *t30s* - длительность теста (time), после которой тест будет завершен.

---

- *Transaction rate (запросов в секунду)* - количество запросов, которые обрабатывает сервер за секунду.
- *Latency (задержка)* - время, которое требуется серверу для обработки запроса.
- *Concurrency (конкурентность)* - количество одновременных соединений или потоков, которые сервер может обслуживать.

---
